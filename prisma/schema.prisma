
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  password  String   // In a real app, hash this!
  role      String   @default("STUDENT") // ADMIN, STUDENT
  division  String   @default("Bronze") // Bronze, Silver, Gold, Platinum
  rating    Int      @default(1200)
  wins      Int      @default(0)
  losses    Int      @default(0)
  draws     Int      @default(0)
  solvedCount Int    @default(0)
  createdAt DateTime @default(now())
  
  submissions Submission[]
  contestParticipants ContestParticipant[]
  duelQueue DuelQueue?
  duelBattlesAsP1 DuelBattle[] @relation("DuelPlayer1")
  duelBattlesAsP2 DuelBattle[] @relation("DuelPlayer2")
  wonDuelBattles DuelBattle[] @relation("DuelWinner")
  duelRatings DuelRatingHistory[]
}

model Problem {
  id          String   @id @default(uuid())
  number      Int      @unique
  title       String
  difficulty  String   @default("BRONZE_5")
  tags        String   @default("")
  description String
  inputDesc   String?
  outputDesc  String?
  timeLimit   Int      @default(1000) // ms
  memoryLimit Int      @default(128)  // MB
  createdAt   DateTime @default(now())
  
  testCases   TestCase[]
  submissions Submission[]
  revisions   ProblemRevision[]
  aiReviews   ProblemAiReview[]
  
  contestId   String?
  contest     Contest? @relation(fields: [contestId], references: [id])
  duelBattles DuelBattle[]
}

model ProblemAiReview {
  id                  String   @id @default(uuid())
  problemId           String
  status              String   @default("PENDING") // PENDING, APPLIED, REJECTED, ERROR
  issues              String   // JSON string array
  proposedDescription String?
  proposedInputDesc   String?
  proposedOutputDesc  String?
  model               String?
  errorMessage        String?
  createdBy           String?
  reviewedBy          String?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  reviewedAt          DateTime?

  problem             Problem  @relation(fields: [problemId], references: [id])

  @@index([problemId, status])
  @@index([status, createdAt])
}

model TestCase {
  id        String  @id @default(uuid())
  input     String
  output    String
  isHidden  Boolean @default(true) // False for example cases
  score     Int     @default(100)
  groupName String  @default("default")
  problemId String
  problem   Problem @relation(fields: [problemId], references: [id])
}

model Submission {
  id        String   @id @default(uuid())
  code      String
  isPublic  Boolean  @default(false)
  codeVisibility String @default("PRIVATE") // PRIVATE, PUBLIC, ACCEPTED_ONLY
  language  String
  status    String   @default("PENDING") // PENDING, ACCEPTED, WRONG_ANSWER, TLE, MLE, COMPILATION_ERROR
  detail    String?
  failedCase Int?
  expectedOutput String?
  actualOutput String?
  totalScore Int?     @default(0)
  maxScore   Int?     @default(0)
  timeUsed  Int?     // ms
  memoryUsed Int?    // KB
  createdAt DateTime @default(now())
  
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  problemId String
  problem   Problem  @relation(fields: [problemId], references: [id])
}

model Contest {
  id          String    @id @default(uuid())
  title       String
  description String?
  startTime   DateTime
  endTime     DateTime
  division    String    @default("Bronze")
  isPublished Boolean   @default(false)
  createdAt   DateTime  @default(now())
  
  problems    Problem[]
  participants ContestParticipant[]
}

model ContestParticipant {
  id        String   @id @default(uuid())
  contestId String
  userId    String
  createdAt DateTime @default(now())

  contest   Contest  @relation(fields: [contestId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([contestId, userId])
  @@index([contestId, createdAt])
}

model DuelQueue {
  id             String   @id @default(uuid())
  userId         String   @unique
  ratingSnapshot Int
  joinedAt       DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([joinedAt])
}

model DuelBattle {
  id                     String    @id @default(uuid())
  problemId              String
  player1Id              String
  player2Id              String
  winnerId               String?
  status                 String    @default("RUNNING") // RUNNING, FINISHED, CANCELLED
  startedAt              DateTime  @default(now())
  endedAt                DateTime?
  durationSec            Int       @default(1800)
  player1AcceptedAt      DateTime?
  player2AcceptedAt      DateTime?
  ratingApplied          Boolean   @default(false)
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt

  problem                Problem   @relation(fields: [problemId], references: [id], onDelete: Restrict)
  player1                User      @relation("DuelPlayer1", fields: [player1Id], references: [id], onDelete: Cascade)
  player2                User      @relation("DuelPlayer2", fields: [player2Id], references: [id], onDelete: Cascade)
  winner                 User?     @relation("DuelWinner", fields: [winnerId], references: [id], onDelete: SetNull)
  ratings                DuelRatingHistory[]

  @@index([status, createdAt])
  @@index([player1Id, status])
  @@index([player2Id, status])
}

model DuelRatingHistory {
  id           String   @id @default(uuid())
  battleId     String
  userId       String
  ratingBefore Int
  ratingAfter  Int
  ratingChange Int
  createdAt    DateTime @default(now())

  battle       DuelBattle @relation(fields: [battleId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([battleId, userId])
}

model PlatformSetting {
  id        String   @id @default(uuid())
  key       String   @unique
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model JudgeQueue {
  id           String   @id @default(uuid())
  submissionId String   @unique
  status       String   @default("PENDING") // PENDING, RUNNING, COMPLETED, FAILED
  attempts     Int      @default(0)
  lastError    String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  startedAt    DateTime?
  finishedAt   DateTime?
}

model RunQueue {
  id         String   @id @default(uuid())
  userId     String?
  problemId  String
  language   String
  code       String
  input      String   @default("")
  timeLimitMs Int     @default(2000)
  status     String   @default("PENDING") // PENDING, RUNNING, COMPLETED, FAILED
  attempts   Int      @default(0)
  resultJson String?
  lastError  String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  startedAt  DateTime?
  finishedAt DateTime?

  @@index([status, createdAt])
}

model ProblemEditorial {
  id         String   @id @default(uuid())
  problemId  String
  authorId   String
  title      String
  content    String
  isOfficial Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model ProblemDiscussion {
  id        String   @id @default(uuid())
  problemId String
  userId    String
  content   String
  parentId  String?
  likeCount Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model DiscussionLike {
  id           String   @id @default(uuid())
  discussionId String
  userId       String
  createdAt    DateTime @default(now())

  @@unique([discussionId, userId])
}

model ProblemRevision {
  id          String   @id @default(uuid())
  problemId   String
  version     Int
  title       String
  description String
  inputDesc   String?
  outputDesc  String?
  timeLimit   Int
  memoryLimit Int
  tags        String
  createdBy   String?
  createdAt   DateTime @default(now())

  problem     Problem  @relation(fields: [problemId], references: [id])

  @@unique([problemId, version])
}

model AutomationSchedule {
  id              String   @id @default(uuid())
  type            String   // "AI_REVIEW" or "AUTO_PROBLEM_GEN"
  enabled         Boolean  @default(true)
  cronExpression  String   // cron format: "0 */6 * * *"
  presetLabel     String?  // "hourly", "every-6-hours", "daily-2am", etc
  lastRunAt       DateTime?
  nextRunAt       DateTime?
  config          String   // JSON string with type-specific settings
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([type])
  @@index([type, enabled])
}
